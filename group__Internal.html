<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spla: Internal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spla
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Internal</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Algorithm.html">spla::Algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1Algorithm.html" title="Algorithm interface.">Algorithm</a> interface.  <a href="classspla_1_1Algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmManager.html">spla::AlgorithmManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages particular algorithms implementations.  <a href="classspla_1_1AlgorithmManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmParams.html">spla::AlgorithmParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Params passed as input to algorithm for execution.  <a href="classspla_1_1AlgorithmParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1detail_1_1BalancedPathKernel.html">spla::detail::BalancedPathKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1detail_1_1SerialIntersectionCountKernel.html">spla::detail::SerialIntersectionCountKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1detail_1_1SerialIntersectionKernel.html">spla::detail::SerialIntersectionKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1DeviceManager.html">spla::DeviceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational devices management for expressions execution.  <a href="classspla_1_1DeviceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Exception.html">spla::Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TException.html">spla::TException&lt; status &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspla_1_1PairHash.html">spla::PairHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1LibraryPrivate.html">spla::LibraryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1QueueFinisher.html">spla::QueueFinisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue wrapper to automate <code>queue.finish()</code> call.  <a href="classspla_1_1QueueFinisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TaskBuilder.html">spla::TaskBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task builder for expression nodes.  <a href="classspla_1_1TaskBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionFuture.html">spla::ExpressionFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for taskflow future.  <a href="classspla_1_1ExpressionFuture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionManager.html">spla::ExpressionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1ExpressionManager.html" title="ExpressionManager.">ExpressionManager</a>.  <a href="classspla_1_1ExpressionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionTasks.html">spla::ExpressionTasks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1NodeProcessor.html">spla::NodeProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the expression node processor class.  <a href="classspla_1_1NodeProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixCOO.html">spla::MatrixCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorCOO.html">spla::VectorCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixBlock.html">spla::MatrixBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixStorage.html">spla::MatrixStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1SplaScalarStorage.html">spla::SplaScalarStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorBlock.html">spla::VectorBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorStorage.html">spla::VectorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::Error &gt;</td></tr>
<tr class="separator:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b50c45990a5db2417f40138767a72a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceError &gt;</td></tr>
<tr class="separator:ga93b50c45990a5db2417f40138767a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fcb67db14febcd2559ac50748f59d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceNotPresent &gt;</td></tr>
<tr class="separator:ga30fcb67db14febcd2559ac50748f59d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4634b302c77cc636953331de02a81c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::MemOpFailed &gt;</td></tr>
<tr class="separator:gafd4634b302c77cc636953331de02a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06715d178091c293c2ec3564827fd9c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidArgument &gt;</td></tr>
<tr class="separator:ga06715d178091c293c2ec3564827fd9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613ae237941a9d20dfaae339d631c775"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidState &gt;</td></tr>
<tr class="separator:ga613ae237941a9d20dfaae339d631c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidType &gt;</td></tr>
<tr class="separator:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NullPointer &gt;</td></tr>
<tr class="separator:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad996df5657793abf71dd4380f1a15e4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DimensionMismatch &gt;</td></tr>
<tr class="separator:gad996df5657793abf71dd4380f1a15e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd969f389137654ed73708fd9450197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NotImplemented &gt;</td></tr>
<tr class="separator:gabcd969f389137654ed73708fd9450197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5251dcc549917ecb7b44ad073c479962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a> { <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd">spla::Error</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a">spla::DeviceError</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3">spla::DeviceNotPresent</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e">spla::PlatformNotPresent</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b">spla::MemOpFailed</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b">spla::InvalidArgument</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120">spla::InvalidState</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810">spla::InvalidType</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c">spla::NullPointer</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463">spla::DimensionMismatch</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e">spla::NotImplemented</a>
<br />
 }</td></tr>
<tr class="separator:ga5251dcc549917ecb7b44ad073c479962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0d5127217f33cc7dec534efb6417496e">spla::Gather</a> (MapIterator first, MapIterator last, InputIterator input, OutputIterator result, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga0d5127217f33cc7dec534efb6417496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6054e8cc8918f728c9e5649e4d75f241"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga6054e8cc8918f728c9e5649e4d75f241">spla::detail::BalancedPathKernel::BalancedPathKernel</a> ()</td></tr>
<tr class="separator:ga6054e8cc8918f728c9e5649e4d75f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9756489f64216c5b5bdd4b97683b8a72"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 , class OutputIterator1 , class OutputIterator2 , class Compare &gt; </td></tr>
<tr class="memitem:ga9756489f64216c5b5bdd4b97683b8a72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga9756489f64216c5b5bdd4b97683b8a72">spla::detail::BalancedPathKernel::set_range</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator1 result_a, OutputIterator2 result_b, Compare comp)</td></tr>
<tr class="separator:ga9756489f64216c5b5bdd4b97683b8a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77262c70ea9245ffd92d260518e46a6"><td class="memItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gaf77262c70ea9245ffd92d260518e46a6">spla::detail::BalancedPathKernel::exec</a> (boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gaf77262c70ea9245ffd92d260518e46a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae147e1018f9169773005273b0d74a600"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gae147e1018f9169773005273b0d74a600">spla::detail::SerialIntersectionCountKernel::SerialIntersectionCountKernel</a> ()</td></tr>
<tr class="separator:gae147e1018f9169773005273b0d74a600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4135ff0af4ee2164174787c1be4dcc25"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class OutputIterator , class Compare , class Equals &gt; </td></tr>
<tr class="memitem:ga4135ff0af4ee2164174787c1be4dcc25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga4135ff0af4ee2164174787c1be4dcc25">spla::detail::SerialIntersectionCountKernel::set_range</a> (InputIterator1 maskFirst, InputIterator2 keyFirsts, InputIterator3 tile_first1, InputIterator3 tile_last1, InputIterator4 tile_first2, OutputIterator counts, Compare compare, Equals equals)</td></tr>
<tr class="separator:ga4135ff0af4ee2164174787c1be4dcc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee974ef9b949ed9dbea0466eb6b97b04"><td class="memItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gaee974ef9b949ed9dbea0466eb6b97b04">spla::detail::SerialIntersectionCountKernel::exec</a> (boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gaee974ef9b949ed9dbea0466eb6b97b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf3c91e29e9bdf38ea912bd2de09195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0bf3c91e29e9bdf38ea912bd2de09195">spla::detail::SerialIntersectionKernel::SerialIntersectionKernel</a> ()</td></tr>
<tr class="separator:ga0bf3c91e29e9bdf38ea912bd2de09195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5aa53402fd55e9d0eed19b6357a72fa"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class InputIterator5 , class Compare , class Equals , class AssignResult &gt; </td></tr>
<tr class="memitem:gac5aa53402fd55e9d0eed19b6357a72fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#gac5aa53402fd55e9d0eed19b6357a72fa">spla::detail::SerialIntersectionKernel::set_range</a> (InputIterator1 maskFirst, InputIterator2 keyFirsts, InputIterator3 tile_first1, InputIterator3 tile_last1, InputIterator4 tile_first2, InputIterator5 counts, Compare compare, Equals equals, AssignResult assignResult)</td></tr>
<tr class="separator:gac5aa53402fd55e9d0eed19b6357a72fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga094ac3dc095e82110d2e95e73eed3eda"><td class="memItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga094ac3dc095e82110d2e95e73eed3eda">spla::detail::SerialIntersectionKernel::exec</a> (boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga094ac3dc095e82110d2e95e73eed3eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d4c8f9bbc5f06d9a07b60428892b3b4"><td class="memTemplParams" colspan="2">template&lt;typename InputMask , typename InputKey , typename Compare , typename Equals , typename ResizeResult , typename AssignResult &gt; </td></tr>
<tr class="memitem:ga0d4c8f9bbc5f06d9a07b60428892b3b4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0d4c8f9bbc5f06d9a07b60428892b3b4">spla::detail::MaskByKey</a> (InputMask maskFirst, InputKey keyFirst, Compare compare, Equals equals, ResizeResult resizeResult, AssignResult assignResult, std::size_t maskCount, std::size_t keyCount, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga0d4c8f9bbc5f06d9a07b60428892b3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1a694da9f8c13ea97619a4ea99ff65"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gada1a694da9f8c13ea97619a4ea99ff65">spla::MaskKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gada1a694da9f8c13ea97619a4ea99ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gada1a694da9f8c13ea97619a4ea99ff65">More...</a><br /></td></tr>
<tr class="separator:gada1a694da9f8c13ea97619a4ea99ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0345fdcaa033dc2833877975283da1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3a0345fdcaa033dc2833877975283da1">spla::MaskByKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3a0345fdcaa033dc2833877975283da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga3a0345fdcaa033dc2833877975283da1">More...</a><br /></td></tr>
<tr class="separator:ga3a0345fdcaa033dc2833877975283da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5a5a65c9e2c075881d3ceb30519d3464">spla::MaskPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga5a5a65c9e2c075881d3ceb30519d3464">More...</a><br /></td></tr>
<tr class="separator:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad2eb9ffa56e5ea335f15364ae65fb4b5">spla::MaskByPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gad2eb9ffa56e5ea335f15364ae65fb4b5">More...</a><br /></td></tr>
<tr class="separator:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">spla::MergeByKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItValuesA valuesA, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItValuesB valuesB, ItKeysResult keysResult, ItValuesResult valuesResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by key) sequences of values by given keys.  <a href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">More...</a><br /></td></tr>
<tr class="separator:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">spla::MergeKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItKeysResult keysResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga606997493cbc46fb9832185c8cdcd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted sequences.  <a href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">More...</a><br /></td></tr>
<tr class="separator:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">spla::MergeByPairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput3 valuesA, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItInput6 valuesB, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, ItOutput3 valuesOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">More...</a><br /></td></tr>
<tr class="separator:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">spla::MergePairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">More...</a><br /></td></tr>
<tr class="separator:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e973ea800af47a29fc2625eb74cf50"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gac1e973ea800af47a29fc2625eb74cf50">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gac1e973ea800af47a29fc2625eb74cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987738a746d84c1abcf41ca3684f8266"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga987738a746d84c1abcf41ca3684f8266">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga987738a746d84c1abcf41ca3684f8266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">spla::SortByRowColumn</a> (boost::compute::vector&lt; unsigned int &gt; &amp;rows, boost::compute::vector&lt; unsigned int &gt; &amp;cols, boost::compute::vector&lt; unsigned char &gt; &amp;vals, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3b363e3578d72cb1311091ed22d0f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort matrix data in coo format in row-column order.  <a href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">More...</a><br /></td></tr>
<tr class="separator:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4dc6e59db274119983bdae31bdf71cca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga4dc6e59db274119983bdae31bdf71cca">spla::detail::BalancedPathKernel::tile_size</a></td></tr>
<tr class="separator:ga4dc6e59db274119983bdae31bdf71cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7ae40503f77b43d83695d310137318"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gaea7ae40503f77b43d83695d310137318">spla::detail::SerialIntersectionCountKernel::tile_size</a></td></tr>
<tr class="separator:gaea7ae40503f77b43d83695d310137318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30ae553abfdad65b0c76d74b2f1fb613"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30ae553abfdad65b0c76d74b2f1fb613">spla::detail::SerialIntersectionKernel::tile_size</a></td></tr>
<tr class="separator:ga30ae553abfdad65b0c76d74b2f1fb613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation details. </p>
<p>The internal module implements the full functionality of the library. It is not anticipated that the user will ever need to work with the objects in this module, as it only contains details of the library's implementation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga93b50c45990a5db2417f40138767a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b50c45990a5db2417f40138767a72a">&#9670;&nbsp;</a></span>DeviceError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceError&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga30fcb67db14febcd2559ac50748f59d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fcb67db14febcd2559ac50748f59d2">&#9670;&nbsp;</a></span>DeviceNotPresent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceNotPresent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad996df5657793abf71dd4380f1a15e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad996df5657793abf71dd4380f1a15e4d">&#9670;&nbsp;</a></span>DimensionMismatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DimensionMismatch&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45d873dd1e17d078c56647d26f0e65ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d873dd1e17d078c56647d26f0e65ec">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::Error&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06715d178091c293c2ec3564827fd9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06715d178091c293c2ec3564827fd9c7">&#9670;&nbsp;</a></span>InvalidArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidArgument&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga613ae237941a9d20dfaae339d631c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613ae237941a9d20dfaae339d631c775">&#9670;&nbsp;</a></span>InvalidState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidState&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafb50a533fa5a48aab0f1dbc73b1f4c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb50a533fa5a48aab0f1dbc73b1f4c35">&#9670;&nbsp;</a></span>InvalidType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafd4634b302c77cc636953331de02a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4634b302c77cc636953331de02a81c">&#9670;&nbsp;</a></span>MemOpFailed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::MemOpFailed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabcd969f389137654ed73708fd9450197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd969f389137654ed73708fd9450197">&#9670;&nbsp;</a></span>NotImplemented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NotImplemented&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga424ab0cd09fe4315b95b4e1d2c3a8064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ab0cd09fe4315b95b4e1d2c3a8064">&#9670;&nbsp;</a></span>NullPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NullPointer&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5251dcc549917ecb7b44ad073c479962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5251dcc549917ecb7b44ad073c479962">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible error status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a"></a>DeviceError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3"></a>DeviceNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e"></a>PlatformNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b"></a>MemOpFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b"></a>InvalidArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120"></a>InvalidState&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c"></a>NullPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6054e8cc8918f728c9e5649e4d75f241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6054e8cc8918f728c9e5649e4d75f241">&#9670;&nbsp;</a></span>BalancedPathKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spla::detail::BalancedPathKernel::BalancedPathKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf77262c70ea9245ffd92d260518e46a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77262c70ea9245ffd92d260518e46a6">&#9670;&nbsp;</a></span>exec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::detail::BalancedPathKernel::exec </td>
          <td>(</td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gaee974ef9b949ed9dbea0466eb6b97b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee974ef9b949ed9dbea0466eb6b97b04">&#9670;&nbsp;</a></span>exec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::detail::SerialIntersectionCountKernel::exec </td>
          <td>(</td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga094ac3dc095e82110d2e95e73eed3eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga094ac3dc095e82110d2e95e73eed3eda">&#9670;&nbsp;</a></span>exec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::detail::SerialIntersectionKernel::exec </td>
          <td>(</td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0d5127217f33cc7dec534efb6417496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5127217f33cc7dec534efb6417496e">&#9670;&nbsp;</a></span>Gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::Gather </td>
          <td>(</td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom gather function. Allows to collect input values using permutation. Uses <code>elementsInSequence</code> to collect several elements in row in sequence, i.e. result[i + k] = input[permutation[i] + k] for k in 0..elementsInSequence for i in map range</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of input source values iterator </td></tr>
    <tr><td class="paramname">MapIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of map (permutation iterator) </td></tr>
    <tr><td class="paramname">OutputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of output (result) gathered values iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Begin of map range </td></tr>
    <tr><td class="paramname">last</td><td>End of map range </td></tr>
    <tr><td class="paramname">input</td><td>Values to map </td></tr>
    <tr><td class="paramname">result</td><td>Where to store result </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>How much values in sequence to copy </td></tr>
    <tr><td class="paramname">queue</td><td>Execution queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d4c8f9bbc5f06d9a07b60428892b3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d4c8f9bbc5f06d9a07b60428892b3b4">&#9670;&nbsp;</a></span>MaskByKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputMask , typename InputKey , typename Compare , typename Equals , typename ResizeResult , typename AssignResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::detail::MaskByKey </td>
          <td>(</td>
          <td class="paramtype">InputMask&#160;</td>
          <td class="paramname"><em>maskFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputKey&#160;</td>
          <td class="paramname"><em>keyFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Equals&#160;</td>
          <td class="paramname"><em>equals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResizeResult&#160;</td>
          <td class="paramname"><em>resizeResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignResult&#160;</td>
          <td class="paramname"><em>assignResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>maskCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>keyCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3a0345fdcaa033dc2833877975283da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a0345fdcaa033dc2833877975283da1">&#9670;&nbsp;</a></span>MaskByKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="gad2eb9ffa56e5ea335f15364ae65fb4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2eb9ffa56e5ea335f15364ae65fb4b5">&#9670;&nbsp;</a></span>MaskByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="gada1a694da9f8c13ea97619a4ea99ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1a694da9f8c13ea97619a4ea99ff65">&#9670;&nbsp;</a></span>MaskKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga5a5a65c9e2c075881d3ceb30519d3464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5a65c9e2c075881d3ceb30519d3464">&#9670;&nbsp;</a></span>MaskPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga1a0da56195e03b6bc46adffcd70d6faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0da56195e03b6bc46adffcd70d6faf">&#9670;&nbsp;</a></span>MergeByKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesA&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesB&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesResult&#160;</td>
          <td class="paramname"><em>valuesResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by key) sequences of values by given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first key sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first key sequence </td></tr>
    <tr><td class="paramname">valuesA</td><td>Begin of the first value sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second key sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second key sequence </td></tr>
    <tr><td class="paramname">valuesB</td><td>Begin of the second value sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the keys result </td></tr>
    <tr><td class="paramname">valuesResult</td><td>Begin of the values result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga3927ef8d235aad2dd37181a5aae58c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3927ef8d235aad2dd37181a5aae58c9b">&#9670;&nbsp;</a></span>MergeByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByPairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput3&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput6&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput3&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga606997493cbc46fb9832185c8cdcd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606997493cbc46fb9832185c8cdcd9e8">&#9670;&nbsp;</a></span>MergeKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga5c492598b8acdfa5f9a2f5d49cb6aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c492598b8acdfa5f9a2f5d49cb6aa72">&#9670;&nbsp;</a></span>MergePairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergePairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga987738a746d84c1abcf41ca3684f8266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987738a746d84c1abcf41ca3684f8266">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabd2c85fd86f63b4e398320400dc66c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2c85fd86f63b4e398320400dc66c3a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac1e973ea800af47a29fc2625eb74cf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e973ea800af47a29fc2625eb74cf50">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06e32a4a916ee651cbbd0c2dabe38f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e32a4a916ee651cbbd0c2dabe38f6a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gae147e1018f9169773005273b0d74a600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae147e1018f9169773005273b0d74a600">&#9670;&nbsp;</a></span>SerialIntersectionCountKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spla::detail::SerialIntersectionCountKernel::SerialIntersectionCountKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0bf3c91e29e9bdf38ea912bd2de09195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf3c91e29e9bdf38ea912bd2de09195">&#9670;&nbsp;</a></span>SerialIntersectionKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">spla::detail::SerialIntersectionKernel::SerialIntersectionKernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9756489f64216c5b5bdd4b97683b8a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9756489f64216c5b5bdd4b97683b8a72">&#9670;&nbsp;</a></span>set_range() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 , class OutputIterator1 , class OutputIterator2 , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::detail::BalancedPathKernel::set_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>result_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>result_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac5aa53402fd55e9d0eed19b6357a72fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5aa53402fd55e9d0eed19b6357a72fa">&#9670;&nbsp;</a></span>set_range() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class InputIterator5 , class Compare , class Equals , class AssignResult &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::detail::SerialIntersectionKernel::set_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>maskFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keyFirsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>tile_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>tile_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>tile_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator5&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Equals&#160;</td>
          <td class="paramname"><em>equals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AssignResult&#160;</td>
          <td class="paramname"><em>assignResult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4135ff0af4ee2164174787c1be4dcc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4135ff0af4ee2164174787c1be4dcc25">&#9670;&nbsp;</a></span>set_range() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class OutputIterator , class Compare , class Equals &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::detail::SerialIntersectionCountKernel::set_range </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>maskFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keyFirsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>tile_first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>tile_last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>tile_first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Equals&#160;</td>
          <td class="paramname"><em>equals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3b363e3578d72cb1311091ed22d0f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b363e3578d72cb1311091ed22d0f84b">&#9670;&nbsp;</a></span>SortByRowColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spla::SortByRowColumn </td>
          <td>(</td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort matrix data in coo format in row-column order. </p>
<dl class="section note"><dt>Note</dt><dd>If elementsInSequence is 0 and vals is empty, sorts only matrix indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with row indices to sort </td></tr>
    <tr><td class="paramname">cols</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with column indices to sort </td></tr>
    <tr><td class="paramname">vals</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with values byte data </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in bytes of values in vals vector </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform sort operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga4dc6e59db274119983bdae31bdf71cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc6e59db274119983bdae31bdf71cca">&#9670;&nbsp;</a></span>tile_size <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int spla::detail::BalancedPathKernel::tile_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaea7ae40503f77b43d83695d310137318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7ae40503f77b43d83695d310137318">&#9670;&nbsp;</a></span>tile_size <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int spla::detail::SerialIntersectionCountKernel::tile_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga30ae553abfdad65b0c76d74b2f1fb613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30ae553abfdad65b0c76d74b2f1fb613">&#9670;&nbsp;</a></span>tile_size <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int spla::detail::SerialIntersectionKernel::tile_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
