<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spla: Internal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spla
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Internal</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Algorithm.html">spla::Algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1Algorithm.html" title="Algorithm interface.">Algorithm</a> interface.  <a href="classspla_1_1Algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmManager.html">spla::AlgorithmManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages particular algorithms implementations.  <a href="classspla_1_1AlgorithmManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmParams.html">spla::AlgorithmParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Params passed as input to algorithm for execution.  <a href="classspla_1_1AlgorithmParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsMatrixEWiseAdd.html">spla::ParamsMatrixEWiseAdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsVectorEWiseAdd.html">spla::ParamsVectorEWiseAdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsMxM.html">spla::ParamsMxM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsVxM.html">spla::ParamsVxM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsVectorAssign.html">spla::ParamsVectorAssign</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1DeviceManager.html">spla::DeviceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational devices management for expressions execution.  <a href="classspla_1_1DeviceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Exception.html">spla::Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TException.html">spla::TException&lt; status &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspla_1_1PairHash.html">spla::PairHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1LibraryPrivate.html">spla::LibraryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1QueueFinisher.html">spla::QueueFinisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue wrapper to automate <code>queue.finish()</code> call.  <a href="classspla_1_1QueueFinisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TaskBuilder.html">spla::TaskBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task builder for expression nodes.  <a href="classspla_1_1TaskBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionFuture.html">spla::ExpressionFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for taskflow future.  <a href="classspla_1_1ExpressionFuture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionManager.html">spla::ExpressionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1ExpressionManager.html" title="ExpressionManager.">ExpressionManager</a>.  <a href="classspla_1_1ExpressionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionTasks.html">spla::ExpressionTasks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1NodeProcessor.html">spla::NodeProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the expression node processor class.  <a href="classspla_1_1NodeProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixCOO.html">spla::MatrixCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorCOO.html">spla::VectorCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixBlock.html">spla::MatrixBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixStorage.html">spla::MatrixStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ScalarStorage.html">spla::ScalarStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorBlock.html">spla::VectorBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorStorage.html">spla::VectorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::Error &gt;</td></tr>
<tr class="separator:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b50c45990a5db2417f40138767a72a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceError &gt;</td></tr>
<tr class="separator:ga93b50c45990a5db2417f40138767a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fcb67db14febcd2559ac50748f59d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceNotPresent &gt;</td></tr>
<tr class="separator:ga30fcb67db14febcd2559ac50748f59d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4634b302c77cc636953331de02a81c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::MemOpFailed &gt;</td></tr>
<tr class="separator:gafd4634b302c77cc636953331de02a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06715d178091c293c2ec3564827fd9c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidArgument &gt;</td></tr>
<tr class="separator:ga06715d178091c293c2ec3564827fd9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613ae237941a9d20dfaae339d631c775"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidState &gt;</td></tr>
<tr class="separator:ga613ae237941a9d20dfaae339d631c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidType &gt;</td></tr>
<tr class="separator:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NullPointer &gt;</td></tr>
<tr class="separator:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad996df5657793abf71dd4380f1a15e4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DimensionMismatch &gt;</td></tr>
<tr class="separator:gad996df5657793abf71dd4380f1a15e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd969f389137654ed73708fd9450197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NotImplemented &gt;</td></tr>
<tr class="separator:gabcd969f389137654ed73708fd9450197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5251dcc549917ecb7b44ad073c479962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a> { <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd">spla::Error</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a">spla::DeviceError</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3">spla::DeviceNotPresent</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e">spla::PlatformNotPresent</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b">spla::MemOpFailed</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b">spla::InvalidArgument</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120">spla::InvalidState</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810">spla::InvalidType</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c">spla::NullPointer</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463">spla::DimensionMismatch</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e">spla::NotImplemented</a>
<br />
 }</td></tr>
<tr class="separator:ga5251dcc549917ecb7b44ad073c479962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga00300e2b3dde5d373d7d9e1d307748c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga00300e2b3dde5d373d7d9e1d307748c8">spla::ApplyMask</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;inputRows, const boost::compute::vector&lt; unsigned char &gt; &amp;inputVals, boost::compute::vector&lt; unsigned int &gt; &amp;outputRows, boost::compute::vector&lt; unsigned char &gt; &amp;outputVals, std::size_t byteSize, bool complement, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga00300e2b3dde5d373d7d9e1d307748c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply mask to coo vector.  <a href="group__Internal.html#ga00300e2b3dde5d373d7d9e1d307748c8">More...</a><br /></td></tr>
<tr class="separator:ga00300e2b3dde5d373d7d9e1d307748c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0d5127217f33cc7dec534efb6417496e">spla::Gather</a> (MapIterator first, MapIterator last, InputIterator input, OutputIterator result, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga0d5127217f33cc7dec534efb6417496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d6fd3b316764e254205dc7133f4201"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30d6fd3b316764e254205dc7133f4201">spla::IndicesToRowOffsets</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;indices, boost::compute::vector&lt; unsigned int &gt; &amp;offsets, boost::compute::vector&lt; unsigned int &gt; &amp;lengths, std::size_t n, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga30d6fd3b316764e254205dc7133f4201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute row offsets from coo row indices buffer.  <a href="group__Internal.html#ga30d6fd3b316764e254205dc7133f4201">More...</a><br /></td></tr>
<tr class="separator:ga30d6fd3b316764e254205dc7133f4201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a135f9660b6d72c3e98a684fff4b5c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gab1a135f9660b6d72c3e98a684fff4b5c">spla::MaskKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, bool complement, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gab1a135f9660b6d72c3e98a684fff4b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gab1a135f9660b6d72c3e98a684fff4b5c">More...</a><br /></td></tr>
<tr class="separator:gab1a135f9660b6d72c3e98a684fff4b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb96ee42d6f3a2b1865e84c9d2e6b7c4"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gacb96ee42d6f3a2b1865e84c9d2e6b7c4">spla::MaskByKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, bool complement, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gacb96ee42d6f3a2b1865e84c9d2e6b7c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gacb96ee42d6f3a2b1865e84c9d2e6b7c4">More...</a><br /></td></tr>
<tr class="separator:gacb96ee42d6f3a2b1865e84c9d2e6b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768b55141ac21d8464832b89d2e8a74c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga768b55141ac21d8464832b89d2e8a74c">spla::MaskPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, bool complement, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga768b55141ac21d8464832b89d2e8a74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga768b55141ac21d8464832b89d2e8a74c">More...</a><br /></td></tr>
<tr class="separator:ga768b55141ac21d8464832b89d2e8a74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c367c12c848bb3b01d26692ba1c3930"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5c367c12c848bb3b01d26692ba1c3930">spla::MaskByPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, bool complement, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5c367c12c848bb3b01d26692ba1c3930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga5c367c12c848bb3b01d26692ba1c3930">More...</a><br /></td></tr>
<tr class="separator:ga5c367c12c848bb3b01d26692ba1c3930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">spla::MergeByKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItValuesA valuesA, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItValuesB valuesB, ItKeysResult keysResult, ItValuesResult valuesResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by key) sequences of values by given keys.  <a href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">More...</a><br /></td></tr>
<tr class="separator:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">spla::MergeKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItKeysResult keysResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga606997493cbc46fb9832185c8cdcd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted sequences.  <a href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">More...</a><br /></td></tr>
<tr class="separator:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">spla::MergeByPairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput3 valuesA, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItInput6 valuesB, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, ItOutput3 valuesOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">More...</a><br /></td></tr>
<tr class="separator:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">spla::MergePairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">More...</a><br /></td></tr>
<tr class="separator:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13f7b0b882862cf7de95039d26b2c6f"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gab13f7b0b882862cf7de95039d26b2c6f">spla::ReduceByPairKey</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;outputIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;outputIndices2, boost::compute::vector&lt; unsigned char &gt; &amp;outputValues, std::size_t valueByteSize, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gab13f7b0b882862cf7de95039d26b2c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The algorithm performs reduction for each contiguous subsequence of aligned values determinate by equivalent keys. <br  />
.  <a href="group__Internal.html#gab13f7b0b882862cf7de95039d26b2c6f">More...</a><br /></td></tr>
<tr class="separator:gab13f7b0b882862cf7de95039d26b2c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d91b72ba4ceb0cdb990516bb5e64455"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga4d91b72ba4ceb0cdb990516bb5e64455">spla::ReduceByKey</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;outputIndices, boost::compute::vector&lt; unsigned char &gt; &amp;outputValues, std::size_t valueByteSize, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga4d91b72ba4ceb0cdb990516bb5e64455"><td class="mdescLeft">&#160;</td><td class="mdescRight">The algorithm performs reduction for each contiguous subsequence of aligned values determinate by equivalent keys. <br  />
.  <a href="group__Internal.html#ga4d91b72ba4ceb0cdb990516bb5e64455">More...</a><br /></td></tr>
<tr class="separator:ga4d91b72ba4ceb0cdb990516bb5e64455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">More...</a><br /></td></tr>
<tr class="separator:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e88e4e8646cce63bdd914347908883"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga16e88e4e8646cce63bdd914347908883">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga16e88e4e8646cce63bdd914347908883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga16e88e4e8646cce63bdd914347908883">More...</a><br /></td></tr>
<tr class="separator:ga16e88e4e8646cce63bdd914347908883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gabd2c85fd86f63b4e398320400dc66c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">More...</a><br /></td></tr>
<tr class="separator:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbc66f32ba851d7a14f6213d3814214"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3fbc66f32ba851d7a14f6213d3814214">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3fbc66f32ba851d7a14f6213d3814214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga3fbc66f32ba851d7a14f6213d3814214">More...</a><br /></td></tr>
<tr class="separator:ga3fbc66f32ba851d7a14f6213d3814214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64f1cbf26dce358c1c0d056ea04db6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gac64f1cbf26dce358c1c0d056ea04db6d">spla::SortByRow</a> (boost::compute::vector&lt; unsigned int &gt; &amp;rows, boost::compute::vector&lt; unsigned char &gt; &amp;vals, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gac64f1cbf26dce358c1c0d056ea04db6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort vector data in coo format in row order.  <a href="group__Internal.html#gac64f1cbf26dce358c1c0d056ea04db6d">More...</a><br /></td></tr>
<tr class="separator:gac64f1cbf26dce358c1c0d056ea04db6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">spla::SortByRowColumn</a> (boost::compute::vector&lt; unsigned int &gt; &amp;rows, boost::compute::vector&lt; unsigned int &gt; &amp;cols, boost::compute::vector&lt; unsigned char &gt; &amp;vals, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3b363e3578d72cb1311091ed22d0f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort matrix data in coo format in row-column order.  <a href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">More...</a><br /></td></tr>
<tr class="separator:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361e8d86479e1f4669f9915cf6389b73"><td class="memItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga361e8d86479e1f4669f9915cf6389b73">spla::TransformValues</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;aMap, const boost::compute::vector&lt; unsigned int &gt; &amp;bMap, const boost::compute::vector&lt; unsigned char &gt; &amp;aValues, const boost::compute::vector&lt; unsigned char &gt; &amp;bValues, boost::compute::vector&lt; unsigned char &gt; &amp;values, std::size_t aByteSize, std::size_t bByteSize, std::size_t resultByteSize, const std::string &amp;transformOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga361e8d86479e1f4669f9915cf6389b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a and b values using map and transfrom op Transforms sequence of a and b values using map to fetch actual a and b values. For each index i of computes result values as v[i] = transform(a[a_map[i]], b[b_map[i]]).  <a href="group__Internal.html#ga361e8d86479e1f4669f9915cf6389b73">More...</a><br /></td></tr>
<tr class="separator:ga361e8d86479e1f4669f9915cf6389b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation details. </p>
<p>The internal module implements the full functionality of the library. It is not anticipated that the user will ever need to work with the objects in this module, as it only contains details of the library's implementation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga93b50c45990a5db2417f40138767a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b50c45990a5db2417f40138767a72a">&#9670;&nbsp;</a></span>DeviceError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceError&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga30fcb67db14febcd2559ac50748f59d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fcb67db14febcd2559ac50748f59d2">&#9670;&nbsp;</a></span>DeviceNotPresent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceNotPresent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad996df5657793abf71dd4380f1a15e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad996df5657793abf71dd4380f1a15e4d">&#9670;&nbsp;</a></span>DimensionMismatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DimensionMismatch&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45d873dd1e17d078c56647d26f0e65ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d873dd1e17d078c56647d26f0e65ec">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::Error&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06715d178091c293c2ec3564827fd9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06715d178091c293c2ec3564827fd9c7">&#9670;&nbsp;</a></span>InvalidArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidArgument&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga613ae237941a9d20dfaae339d631c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613ae237941a9d20dfaae339d631c775">&#9670;&nbsp;</a></span>InvalidState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidState&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafb50a533fa5a48aab0f1dbc73b1f4c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb50a533fa5a48aab0f1dbc73b1f4c35">&#9670;&nbsp;</a></span>InvalidType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafd4634b302c77cc636953331de02a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4634b302c77cc636953331de02a81c">&#9670;&nbsp;</a></span>MemOpFailed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::MemOpFailed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabcd969f389137654ed73708fd9450197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd969f389137654ed73708fd9450197">&#9670;&nbsp;</a></span>NotImplemented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NotImplemented&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga424ab0cd09fe4315b95b4e1d2c3a8064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ab0cd09fe4315b95b4e1d2c3a8064">&#9670;&nbsp;</a></span>NullPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NullPointer&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5251dcc549917ecb7b44ad073c479962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5251dcc549917ecb7b44ad073c479962">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible error status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a"></a>DeviceError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3"></a>DeviceNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e"></a>PlatformNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b"></a>MemOpFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b"></a>InvalidArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120"></a>InvalidState&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c"></a>NullPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga00300e2b3dde5d373d7d9e1d307748c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00300e2b3dde5d373d7d9e1d307748c8">&#9670;&nbsp;</a></span>ApplyMask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::ApplyMask </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>byteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply mask to coo vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask indices </td></tr>
    <tr><td class="paramname">inputRows</td><td>Row indices </td></tr>
    <tr><td class="paramname">inputVals</td><td>Values </td></tr>
    <tr><td class="paramname">outputRows</td><td>Result row indices; resized automatically </td></tr>
    <tr><td class="paramname">outputVals</td><td>Result values; resized automatically </td></tr>
    <tr><td class="paramname">byteSize</td><td>Size of values; if 0, apply only indices mask </td></tr>
    <tr><td class="paramname">complement</td><td>Pass true to apply inverse (complementary mask) </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d5127217f33cc7dec534efb6417496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5127217f33cc7dec534efb6417496e">&#9670;&nbsp;</a></span>Gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::Gather </td>
          <td>(</td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom gather function. Allows to collect input values using permutation. Uses <code>elementsInSequence</code> to collect several elements in row in sequence, i.e. result[i + k] = input[permutation[i] + k] for k in 0..elementsInSequence for i in map range</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of input source values iterator </td></tr>
    <tr><td class="paramname">MapIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of map (permutation iterator) </td></tr>
    <tr><td class="paramname">OutputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of output (result) gathered values iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Begin of map range </td></tr>
    <tr><td class="paramname">last</td><td>End of map range </td></tr>
    <tr><td class="paramname">input</td><td>Values to map </td></tr>
    <tr><td class="paramname">result</td><td>Where to store result </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>How much values in sequence to copy </td></tr>
    <tr><td class="paramname">queue</td><td>Execution queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30d6fd3b316764e254205dc7133f4201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30d6fd3b316764e254205dc7133f4201">&#9670;&nbsp;</a></span>IndicesToRowOffsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::IndicesToRowOffsets </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute row offsets from coo row indices buffer. </p>
<p>Result offsets array has size n + 1. Offsets[i] stores first index of row i in indices buffer. Offsets[i + 1] - Offsets[i] equals number of nnz values in row i in indices buffer. Offsets[n] equals number off values in indices buffer. Lengths[i] equals number of nnz values in row i in indices buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">indices</td><td>Array of rows indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>Output array with offsets </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lengths</td><td>Output array of row lengths </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">n</td><td>Number of rows in matrix </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue</td><td>Command queue to execute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb96ee42d6f3a2b1865e84c9d2e6b7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb96ee42d6f3a2b1865e84c9d2e6b7c4">&#9670;&nbsp;</a></span>MaskByKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Automatically resizes result containers to result count size. </dd>
<dd>
Use complement flag to apply direct or inverse (complement) mask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">complement</td><td>Pass true to apply !mask (complementary mask) </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga5c367c12c848bb3b01d26692ba1c3930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c367c12c848bb3b01d26692ba1c3930">&#9670;&nbsp;</a></span>MaskByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size. </dd>
<dd>
Use complement flag to apply direct or inverse (complement) mask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">complement</td><td>Pass true to apply !mask (complementary mask) </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="gab1a135f9660b6d72c3e98a684fff4b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1a135f9660b6d72c3e98a684fff4b5c">&#9670;&nbsp;</a></span>MaskKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Automatically resizes result containers to result count size. </dd>
<dd>
Use complement flag to apply direct or inverse (complement) mask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">complement</td><td>Pass true to apply !mask (complementary mask) </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga768b55141ac21d8464832b89d2e8a74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768b55141ac21d8464832b89d2e8a74c">&#9670;&nbsp;</a></span>MaskPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>complement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size. </dd>
<dd>
Use complement flag to apply direct or inverse (complement) mask</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">complement</td><td>Pass true to apply !mask (complementary mask) </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga1a0da56195e03b6bc46adffcd70d6faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0da56195e03b6bc46adffcd70d6faf">&#9670;&nbsp;</a></span>MergeByKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesA&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesB&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesResult&#160;</td>
          <td class="paramname"><em>valuesResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by key) sequences of values by given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first key sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first key sequence </td></tr>
    <tr><td class="paramname">valuesA</td><td>Begin of the first value sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second key sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second key sequence </td></tr>
    <tr><td class="paramname">valuesB</td><td>Begin of the second value sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the keys result </td></tr>
    <tr><td class="paramname">valuesResult</td><td>Begin of the values result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga3927ef8d235aad2dd37181a5aae58c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3927ef8d235aad2dd37181a5aae58c9b">&#9670;&nbsp;</a></span>MergeByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByPairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput3&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput6&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput3&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga606997493cbc46fb9832185c8cdcd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606997493cbc46fb9832185c8cdcd9e8">&#9670;&nbsp;</a></span>MergeKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga5c492598b8acdfa5f9a2f5d49cb6aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c492598b8acdfa5f9a2f5d49cb6aa72">&#9670;&nbsp;</a></span>MergePairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergePairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga4d91b72ba4ceb0cdb990516bb5e64455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d91b72ba4ceb0cdb990516bb5e64455">&#9670;&nbsp;</a></span>ReduceByKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceByKey </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>valueByteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The algorithm performs reduction for each contiguous subsequence of aligned values determinate by equivalent keys. <br  />
. </p>
<p>Aligned value - a sequence of bytes of size <code>valueByteSize</code>. Values must be packed without offsets and paddings.</p>
<dl class="section note"><dt>Note</dt><dd>Reduce function must be associative. Otherwise, reduction result for values with the same keys is not defined.</dd>
<dd>
Output vectors (such as <code>outputValues</code>, <code>outputIndices</code>) are resized during <code>ReduceByKey</code> execution. Hence, there is no need to resize them beforehand.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> of keys </td></tr>
    <tr><td class="paramname">inputValues</td><td>Sequence of bytes, where values are packed </td></tr>
    <tr><td class="paramname">outputIndices</td><td>Output sequence of keys </td></tr>
    <tr><td class="paramname">outputValues</td><td>Output sequence of value's bytes </td></tr>
    <tr><td class="paramname">valueByteSize</td><td>Size of each value </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Body of the reduce function </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL command queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the resulting key sequence</dd></dl>
<p>the <code>ReduceByKeyWithScan</code> for the implementation details </p>

</div>
</div>
<a id="gab13f7b0b882862cf7de95039d26b2c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab13f7b0b882862cf7de95039d26b2c6f">&#9670;&nbsp;</a></span>ReduceByPairKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceByPairKey </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>outputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>valueByteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The algorithm performs reduction for each contiguous subsequence of aligned values determinate by equivalent keys. <br  />
. </p>
<p>Aligned value - a sequence of bytes of size <code>valueByteSize</code>. Values must be packed without offsets and paddings. <br  />
 Two keys are assumed to be equal if and only if two keys from key sequences are match.</p>
<dl class="section note"><dt>Note</dt><dd>Reduce function must be associative. Otherwise, reduction result for values with the same keys is not defined.</dd>
<dd>
Output vectors (such as <code>outputValues</code>, <code>outputIndices*</code>) are resized during <code>ReduceByPairKey</code> execution. Hence, there is no need to resize them beforehand.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices1</td><td>First sequence of keys </td></tr>
    <tr><td class="paramname">inputIndices2</td><td>Second sequence of keys </td></tr>
    <tr><td class="paramname">inputValues</td><td>Sequence of bytes, where values are packed </td></tr>
    <tr><td class="paramname">outputIndices1</td><td>Output sequence of first keys </td></tr>
    <tr><td class="paramname">outputIndices2</td><td>Output sequence of second keys </td></tr>
    <tr><td class="paramname">outputValues</td><td>Output sequence of value's bytes </td></tr>
    <tr><td class="paramname">valueByteSize</td><td>Size of each value </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Body of the reduce function </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL command queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the resulting keys sequence</dd></dl>
<p>the <code>ReduceByKeyWithScan</code> for the implementation details </p>

</div>
</div>
<a id="ga3fbc66f32ba851d7a14f6213d3814214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbc66f32ba851d7a14f6213d3814214">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices</td><td>Keys elements </td></tr>
    <tr><td class="paramname">resultIndices</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="gabd2c85fd86f63b4e398320400dc66c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2c85fd86f63b4e398320400dc66c3a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Reduces values associated with keys using provided reduceOp. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices</td><td>Keys elements </td></tr>
    <tr><td class="paramname">inputValues</td><td>Input values associated with keys </td></tr>
    <tr><td class="paramname">resultIndices</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result reduced values </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in byte of single value in raw values buffer </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Binary operation used to reduce duplicated values </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="ga16e88e4e8646cce63bdd914347908883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e88e4e8646cce63bdd914347908883">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Keys interpreted as pairs stored in separate containers. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">inputIndices2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">resultIndices1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultIndices2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="ga06e32a4a916ee651cbbd0c2dabe38f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e32a4a916ee651cbbd0c2dabe38f6a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Keys interpreted as pairs stored in separate containers. </dd>
<dd>
Reduces values associated with keys using provided reduceOp. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">inputIndices2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">inputValues</td><td>Input values associated with keys </td></tr>
    <tr><td class="paramname">resultIndices1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultIndices2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result reduced values </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in byte of single value in raw values buffer </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Binary operation used to reduce duplicated values </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="gac64f1cbf26dce358c1c0d056ea04db6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64f1cbf26dce358c1c0d056ea04db6d">&#9670;&nbsp;</a></span>SortByRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spla::SortByRow </td>
          <td>(</td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort vector data in coo format in row order. </p>
<dl class="section note"><dt>Note</dt><dd>If elementsInSequence is 0 and vals is empty, sorts only vector indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with row indices to sort </td></tr>
    <tr><td class="paramname">vals</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with values byte data </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in bytes of values in vals vector </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform sort operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b363e3578d72cb1311091ed22d0f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b363e3578d72cb1311091ed22d0f84b">&#9670;&nbsp;</a></span>SortByRowColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spla::SortByRowColumn </td>
          <td>(</td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort matrix data in coo format in row-column order. </p>
<dl class="section note"><dt>Note</dt><dd>If elementsInSequence is 0 and vals is empty, sorts only matrix indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with row indices to sort </td></tr>
    <tr><td class="paramname">cols</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with column indices to sort </td></tr>
    <tr><td class="paramname">vals</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with values byte data </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in bytes of values in vals vector </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform sort operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga361e8d86479e1f4669f9915cf6389b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga361e8d86479e1f4669f9915cf6389b73">&#9670;&nbsp;</a></span>TransformValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::TransformValues </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>aMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>aValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>bValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>aByteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>bByteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>resultByteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>transformOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a and b values using map and transfrom op Transforms sequence of a and b values using map to fetch actual a and b values. For each index i of computes result values as v[i] = transform(a[a_map[i]], b[b_map[i]]). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aMap</td><td>Map for a values </td></tr>
    <tr><td class="paramname">bMap</td><td>Map for b values </td></tr>
    <tr><td class="paramname">aValues</td><td>A values </td></tr>
    <tr><td class="paramname">bValues</td><td>B values </td></tr>
    <tr><td class="paramname">values</td><td>Where to store result of transformation; must be allocated by the user </td></tr>
    <tr><td class="paramname">aByteSize</td><td>Size of a values </td></tr>
    <tr><td class="paramname">bByteSize</td><td>Size of b values </td></tr>
    <tr><td class="paramname">resultByteSize</td><td>Size of result values </td></tr>
    <tr><td class="paramname">transformOp</td><td>Source code for transform function </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event to syn this operation </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
