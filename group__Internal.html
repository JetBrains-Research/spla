<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spla: Internal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spla
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Internal</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Algorithm.html">spla::Algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1Algorithm.html" title="Algorithm interface.">Algorithm</a> interface.  <a href="classspla_1_1Algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmManager.html">spla::AlgorithmManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages particular algorithms implementations.  <a href="classspla_1_1AlgorithmManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmParams.html">spla::AlgorithmParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Params passed as input to algorithm for execution.  <a href="classspla_1_1AlgorithmParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1DeviceManager.html">spla::DeviceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational devices management for expressions execution.  <a href="classspla_1_1DeviceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Exception.html">spla::Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TException.html">spla::TException&lt; status &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspla_1_1PairHash.html">spla::PairHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1LibraryPrivate.html">spla::LibraryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1QueueFinisher.html">spla::QueueFinisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue wrapper to automate <code>queue.finish()</code> call.  <a href="classspla_1_1QueueFinisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TaskBuilder.html">spla::TaskBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task builder for expression nodes.  <a href="classspla_1_1TaskBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionFuture.html">spla::ExpressionFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for taskflow future.  <a href="classspla_1_1ExpressionFuture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionManager.html">spla::ExpressionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1ExpressionManager.html" title="ExpressionManager.">ExpressionManager</a>.  <a href="classspla_1_1ExpressionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionTasks.html">spla::ExpressionTasks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1NodeProcessor.html">spla::NodeProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the expression node processor class.  <a href="classspla_1_1NodeProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixCOO.html">spla::MatrixCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorCOO.html">spla::VectorCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixBlock.html">spla::MatrixBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixStorage.html">spla::MatrixStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1SplaScalarStorage.html">spla::SplaScalarStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorBlock.html">spla::VectorBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorStorage.html">spla::VectorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::Error &gt;</td></tr>
<tr class="separator:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b50c45990a5db2417f40138767a72a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceError &gt;</td></tr>
<tr class="separator:ga93b50c45990a5db2417f40138767a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fcb67db14febcd2559ac50748f59d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceNotPresent &gt;</td></tr>
<tr class="separator:ga30fcb67db14febcd2559ac50748f59d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4634b302c77cc636953331de02a81c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::MemOpFailed &gt;</td></tr>
<tr class="separator:gafd4634b302c77cc636953331de02a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06715d178091c293c2ec3564827fd9c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidArgument &gt;</td></tr>
<tr class="separator:ga06715d178091c293c2ec3564827fd9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613ae237941a9d20dfaae339d631c775"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidState &gt;</td></tr>
<tr class="separator:ga613ae237941a9d20dfaae339d631c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidType &gt;</td></tr>
<tr class="separator:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NullPointer &gt;</td></tr>
<tr class="separator:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad996df5657793abf71dd4380f1a15e4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DimensionMismatch &gt;</td></tr>
<tr class="separator:gad996df5657793abf71dd4380f1a15e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd969f389137654ed73708fd9450197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NotImplemented &gt;</td></tr>
<tr class="separator:gabcd969f389137654ed73708fd9450197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5251dcc549917ecb7b44ad073c479962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a> { <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd">spla::Error</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a">spla::DeviceError</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3">spla::DeviceNotPresent</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e">spla::PlatformNotPresent</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b">spla::MemOpFailed</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b">spla::InvalidArgument</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120">spla::InvalidState</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810">spla::InvalidType</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c">spla::NullPointer</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463">spla::DimensionMismatch</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e">spla::NotImplemented</a>
<br />
 }</td></tr>
<tr class="separator:ga5251dcc549917ecb7b44ad073c479962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0d5127217f33cc7dec534efb6417496e">spla::Gather</a> (MapIterator first, MapIterator last, InputIterator input, OutputIterator result, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga0d5127217f33cc7dec534efb6417496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f1d2f58e52c128ff595baf61e0597c"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class OutputIterator1 , class OutputIterator2 , class Compare , class Equals &gt; </td></tr>
<tr class="memitem:gaf3f1d2f58e52c128ff595baf61e0597c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#gaf3f1d2f58e52c128ff595baf61e0597c">spla::MaskByKey</a> (InputIterator1 maskFirst, InputIterator1 maskLast, InputIterator2 keyFirsts, InputIterator2 keyLast, InputIterator3 valueFirst, OutputIterator1 resultKeys, OutputIterator2 resultValues, Compare compare, Equals equals, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gaf3f1d2f58e52c128ff595baf61e0597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gaf3f1d2f58e52c128ff595baf61e0597c">More...</a><br /></td></tr>
<tr class="separator:gaf3f1d2f58e52c128ff595baf61e0597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bf766e718d9fd6a36fa8f62e3edfaf2"><td class="memTemplParams" colspan="2">template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class InputIterator5 , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 &gt; </td></tr>
<tr class="memitem:ga2bf766e718d9fd6a36fa8f62e3edfaf2"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga2bf766e718d9fd6a36fa8f62e3edfaf2">spla::MaskByPairKey</a> (InputIterator1 mask1First, InputIterator1 mask1Last, InputIterator2 mask2First, InputIterator3 key1Firsts, InputIterator3 key1Last, InputIterator4 key2Firsts, InputIterator5 valueFirst, OutputIterator1 resultKeys1, OutputIterator2 resultKeys2, OutputIterator3 resultValues, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga2bf766e718d9fd6a36fa8f62e3edfaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">spla::MergeByKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItValuesA valuesA, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItValuesB valuesB, ItKeysResult keysResult, ItValuesResult valuesResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by key) sequences of values by given keys.  <a href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">More...</a><br /></td></tr>
<tr class="separator:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">spla::MergeKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItKeysResult keysResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga606997493cbc46fb9832185c8cdcd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted sequences.  <a href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">More...</a><br /></td></tr>
<tr class="separator:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">spla::MergeByPairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput3 valuesA, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItInput6 valuesB, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, ItOutput3 valuesOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">More...</a><br /></td></tr>
<tr class="separator:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">spla::MergePairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">More...</a><br /></td></tr>
<tr class="separator:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e973ea800af47a29fc2625eb74cf50"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gac1e973ea800af47a29fc2625eb74cf50">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gac1e973ea800af47a29fc2625eb74cf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987738a746d84c1abcf41ca3684f8266"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga987738a746d84c1abcf41ca3684f8266">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga987738a746d84c1abcf41ca3684f8266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">spla::SortByRowColumn</a> (boost::compute::vector&lt; unsigned int &gt; &amp;rows, boost::compute::vector&lt; unsigned int &gt; &amp;cols, boost::compute::vector&lt; unsigned char &gt; &amp;vals, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3b363e3578d72cb1311091ed22d0f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort matrix data in coo format in row-column order.  <a href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">More...</a><br /></td></tr>
<tr class="separator:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation details. </p>
<p>The internal module implements the full functionality of the library. It is not anticipated that the user will ever need to work with the objects in this module, as it only contains details of the library's implementation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga93b50c45990a5db2417f40138767a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b50c45990a5db2417f40138767a72a">&#9670;&nbsp;</a></span>DeviceError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceError&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga30fcb67db14febcd2559ac50748f59d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fcb67db14febcd2559ac50748f59d2">&#9670;&nbsp;</a></span>DeviceNotPresent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceNotPresent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad996df5657793abf71dd4380f1a15e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad996df5657793abf71dd4380f1a15e4d">&#9670;&nbsp;</a></span>DimensionMismatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DimensionMismatch&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45d873dd1e17d078c56647d26f0e65ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d873dd1e17d078c56647d26f0e65ec">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::Error&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06715d178091c293c2ec3564827fd9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06715d178091c293c2ec3564827fd9c7">&#9670;&nbsp;</a></span>InvalidArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidArgument&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga613ae237941a9d20dfaae339d631c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613ae237941a9d20dfaae339d631c775">&#9670;&nbsp;</a></span>InvalidState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidState&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafb50a533fa5a48aab0f1dbc73b1f4c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb50a533fa5a48aab0f1dbc73b1f4c35">&#9670;&nbsp;</a></span>InvalidType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafd4634b302c77cc636953331de02a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4634b302c77cc636953331de02a81c">&#9670;&nbsp;</a></span>MemOpFailed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::MemOpFailed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabcd969f389137654ed73708fd9450197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd969f389137654ed73708fd9450197">&#9670;&nbsp;</a></span>NotImplemented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NotImplemented&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga424ab0cd09fe4315b95b4e1d2c3a8064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ab0cd09fe4315b95b4e1d2c3a8064">&#9670;&nbsp;</a></span>NullPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NullPointer&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5251dcc549917ecb7b44ad073c479962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5251dcc549917ecb7b44ad073c479962">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible error status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a"></a>DeviceError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3"></a>DeviceNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e"></a>PlatformNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b"></a>MemOpFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b"></a>InvalidArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120"></a>InvalidState&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c"></a>NullPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0d5127217f33cc7dec534efb6417496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5127217f33cc7dec534efb6417496e">&#9670;&nbsp;</a></span>Gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::Gather </td>
          <td>(</td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom gather function. Allows to collect input values using permutation. Uses <code>elementsInSequence</code> to collect several elements in row in sequence, i.e. result[i + k] = input[permutation[i] + k] for k in 0..elementsInSequence for i in map range</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of input source values iterator </td></tr>
    <tr><td class="paramname">MapIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of map (permutation iterator) </td></tr>
    <tr><td class="paramname">OutputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of output (result) gathered values iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Begin of map range </td></tr>
    <tr><td class="paramname">last</td><td>End of map range </td></tr>
    <tr><td class="paramname">input</td><td>Values to map </td></tr>
    <tr><td class="paramname">result</td><td>Where to store result </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>How much values in sequence to copy </td></tr>
    <tr><td class="paramname">queue</td><td>Execution queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3f1d2f58e52c128ff595baf61e0597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3f1d2f58e52c128ff595baf61e0597c">&#9670;&nbsp;</a></span>MaskByKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class OutputIterator1 , class OutputIterator2 , class Compare , class Equals &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByKey </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>maskFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>maskLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keyFirsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>keyLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>valueFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Equals&#160;</td>
          <td class="paramname"><em>equals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range [maskFirst, maskLast) with the sorted keys range [keyFirsts, keyLast) and stores it in range starting at resultKeys with values associated to key range.</p>
<div class="fragment"><div class="line">vector&lt;uint&gt; mask = { 0, 3, 5, 10 };</div>
<div class="line">vector&lt;uint&gt; keys = { 0, 1, 2, 3, 7, 10 };</div>
<div class="line">vector&lt;uint&gt; values = { 10, 1, 2, 53, 4, 775 };</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__Internal.html#gaf3f1d2f58e52c128ff595baf61e0597c">MaskByKey</a>(mask.begin(), mask.end(), key.begin(), key.end(), values.begin(),</div>
<div class="line">          keys.begin(), values.begin(), queue);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// keys = { 0, 3, 10 }</span></div>
<div class="line"><span class="comment">// values = {10, 2, 53, 775 }</span></div>
<div class="ttc" id="agroup__Internal_html_gaf3f1d2f58e52c128ff595baf61e0597c"><div class="ttname"><a href="group__Internal.html#gaf3f1d2f58e52c128ff595baf61e0597c">spla::MaskByKey</a></div><div class="ttdeci">std::size_t MaskByKey(InputIterator1 maskFirst, InputIterator1 maskLast, InputIterator2 keyFirsts, InputIterator2 keyLast, InputIterator3 valueFirst, OutputIterator1 resultKeys, OutputIterator2 resultValues, Compare compare, Equals equals, boost::compute::command_queue &amp;queue)</div><div class="ttdoc">Mask intersection algorithm.</div><div class="ttdef"><b>Definition:</b> SplaMaskByKey.hpp:266</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator1</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of mask iterator </td></tr>
    <tr><td class="paramname">InputIterator2</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of keys iterator </td></tr>
    <tr><td class="paramname">InputIterator3</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of values iterator </td></tr>
    <tr><td class="paramname">OutputIterator1</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of result keys iterator </td></tr>
    <tr><td class="paramname">OutputIterator2</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of result values iterator </td></tr>
    <tr><td class="paramname">Compare</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of mask/keys '&lt;' functor </td></tr>
    <tr><td class="paramname">Equals</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of mask/keys '==' functor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maskFirst</td><td>Begin of the mask </td></tr>
    <tr><td class="paramname">maskLast</td><td>End of the mask </td></tr>
    <tr><td class="paramname">keyFirsts</td><td>Begin of keys </td></tr>
    <tr><td class="paramname">keyLast</td><td>End of keys </td></tr>
    <tr><td class="paramname">valueFirst</td><td>Begin of values (range the same as for keys) </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Keys result begin </td></tr>
    <tr><td class="paramname">resultValues</td><td>Values result begin </td></tr>
    <tr><td class="paramname">compare</td><td>Mask/keys compare function </td></tr>
    <tr><td class="paramname">equals</td><td>Mask/keys compare function </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to execute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga2bf766e718d9fd6a36fa8f62e3edfaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf766e718d9fd6a36fa8f62e3edfaf2">&#9670;&nbsp;</a></span>MaskByPairKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator1 , class InputIterator2 , class InputIterator3 , class InputIterator4 , class InputIterator5 , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByPairKey </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>mask1First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>mask1Last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>mask2First</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>key1Firsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>key1Last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator4&#160;</td>
          <td class="paramname"><em>key2Firsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator5&#160;</td>
          <td class="paramname"><em>valueFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1a0da56195e03b6bc46adffcd70d6faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0da56195e03b6bc46adffcd70d6faf">&#9670;&nbsp;</a></span>MergeByKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesA&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesB&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesResult&#160;</td>
          <td class="paramname"><em>valuesResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by key) sequences of values by given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first key sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first key sequence </td></tr>
    <tr><td class="paramname">valuesA</td><td>Begin of the first value sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second key sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second key sequence </td></tr>
    <tr><td class="paramname">valuesB</td><td>Begin of the second value sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the keys result </td></tr>
    <tr><td class="paramname">valuesResult</td><td>Begin of the values result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga3927ef8d235aad2dd37181a5aae58c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3927ef8d235aad2dd37181a5aae58c9b">&#9670;&nbsp;</a></span>MergeByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByPairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput3&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput6&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput3&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga606997493cbc46fb9832185c8cdcd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606997493cbc46fb9832185c8cdcd9e8">&#9670;&nbsp;</a></span>MergeKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga5c492598b8acdfa5f9a2f5d49cb6aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c492598b8acdfa5f9a2f5d49cb6aa72">&#9670;&nbsp;</a></span>MergePairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergePairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga987738a746d84c1abcf41ca3684f8266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987738a746d84c1abcf41ca3684f8266">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gabd2c85fd86f63b4e398320400dc66c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2c85fd86f63b4e398320400dc66c3a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="gac1e973ea800af47a29fc2625eb74cf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1e973ea800af47a29fc2625eb74cf50">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06e32a4a916ee651cbbd0c2dabe38f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e32a4a916ee651cbbd0c2dabe38f6a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga3b363e3578d72cb1311091ed22d0f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b363e3578d72cb1311091ed22d0f84b">&#9670;&nbsp;</a></span>SortByRowColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spla::SortByRowColumn </td>
          <td>(</td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort matrix data in coo format in row-column order. </p>
<dl class="section note"><dt>Note</dt><dd>If elementsInSequence is 0 and vals is empty, sorts only matrix indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with row indices to sort </td></tr>
    <tr><td class="paramname">cols</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with column indices to sort </td></tr>
    <tr><td class="paramname">vals</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with values byte data </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in bytes of values in vals vector </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform sort operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
