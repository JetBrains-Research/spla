<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spla: Internal</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spla
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Internal</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Algorithm.html">spla::Algorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1Algorithm.html" title="Algorithm interface.">Algorithm</a> interface.  <a href="classspla_1_1Algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmManager.html">spla::AlgorithmManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages particular algorithms implementations.  <a href="classspla_1_1AlgorithmManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1AlgorithmParams.html">spla::AlgorithmParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Params passed as input to algorithm for execution.  <a href="classspla_1_1AlgorithmParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsMatrixEWiseAdd.html">spla::ParamsMatrixEWiseAdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsVectorEWiseAdd.html">spla::ParamsVectorEWiseAdd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ParamsMxM.html">spla::ParamsMxM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1DeviceManager.html">spla::DeviceManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational devices management for expressions execution.  <a href="classspla_1_1DeviceManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1Exception.html">spla::Exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TException.html">spla::TException&lt; status &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspla_1_1PairHash.html">spla::PairHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1LibraryPrivate.html">spla::LibraryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1QueueFinisher.html">spla::QueueFinisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue wrapper to automate <code>queue.finish()</code> call.  <a href="classspla_1_1QueueFinisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1TaskBuilder.html">spla::TaskBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task builder for expression nodes.  <a href="classspla_1_1TaskBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionFuture.html">spla::ExpressionFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for taskflow future.  <a href="classspla_1_1ExpressionFuture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionManager.html">spla::ExpressionManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classspla_1_1ExpressionManager.html" title="ExpressionManager.">ExpressionManager</a>.  <a href="classspla_1_1ExpressionManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ExpressionTasks.html">spla::ExpressionTasks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1NodeProcessor.html">spla::NodeProcessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the expression node processor class.  <a href="classspla_1_1NodeProcessor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixCOO.html">spla::MatrixCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorCOO.html">spla::VectorCOO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixBlock.html">spla::MatrixBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1MatrixStorage.html">spla::MatrixStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1ScalarStorage.html">spla::ScalarStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorBlock.html">spla::VectorBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspla_1_1VectorStorage.html">spla::VectorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::Error &gt;</td></tr>
<tr class="separator:ga45d873dd1e17d078c56647d26f0e65ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93b50c45990a5db2417f40138767a72a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceError &gt;</td></tr>
<tr class="separator:ga93b50c45990a5db2417f40138767a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fcb67db14febcd2559ac50748f59d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DeviceNotPresent &gt;</td></tr>
<tr class="separator:ga30fcb67db14febcd2559ac50748f59d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd4634b302c77cc636953331de02a81c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::MemOpFailed &gt;</td></tr>
<tr class="separator:gafd4634b302c77cc636953331de02a81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06715d178091c293c2ec3564827fd9c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidArgument &gt;</td></tr>
<tr class="separator:ga06715d178091c293c2ec3564827fd9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga613ae237941a9d20dfaae339d631c775"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidState &gt;</td></tr>
<tr class="separator:ga613ae237941a9d20dfaae339d631c775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::InvalidType &gt;</td></tr>
<tr class="separator:gafb50a533fa5a48aab0f1dbc73b1f4c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NullPointer &gt;</td></tr>
<tr class="separator:ga424ab0cd09fe4315b95b4e1d2c3a8064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad996df5657793abf71dd4380f1a15e4d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::DimensionMismatch &gt;</td></tr>
<tr class="separator:gad996df5657793abf71dd4380f1a15e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd969f389137654ed73708fd9450197"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = <a class="el" href="classspla_1_1TException.html">TException</a>&lt; Status::NotImplemented &gt;</td></tr>
<tr class="separator:gabcd969f389137654ed73708fd9450197"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5251dcc549917ecb7b44ad073c479962"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a> { <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd">spla::Error</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a">spla::DeviceError</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3">spla::DeviceNotPresent</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e">spla::PlatformNotPresent</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b">spla::MemOpFailed</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b">spla::InvalidArgument</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120">spla::InvalidState</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810">spla::InvalidType</a>
, <br />
&#160;&#160;<a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c">spla::NullPointer</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463">spla::DimensionMismatch</a>
, <a class="el" href="group__Internal.html#gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e">spla::NotImplemented</a>
<br />
 }</td></tr>
<tr class="separator:ga5251dcc549917ecb7b44ad073c479962"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d5127217f33cc7dec534efb6417496e"><td class="memTemplItemLeft" align="right" valign="top">boost::compute::event&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga0d5127217f33cc7dec534efb6417496e">spla::Gather</a> (MapIterator first, MapIterator last, InputIterator input, OutputIterator result, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="separator:ga0d5127217f33cc7dec534efb6417496e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada1a694da9f8c13ea97619a4ea99ff65"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gada1a694da9f8c13ea97619a4ea99ff65">spla::MaskKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gada1a694da9f8c13ea97619a4ea99ff65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gada1a694da9f8c13ea97619a4ea99ff65">More...</a><br /></td></tr>
<tr class="separator:gada1a694da9f8c13ea97619a4ea99ff65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a0345fdcaa033dc2833877975283da1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3a0345fdcaa033dc2833877975283da1">spla::MaskByKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask, const boost::compute::vector&lt; unsigned int &gt; &amp;keys, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3a0345fdcaa033dc2833877975283da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga3a0345fdcaa033dc2833877975283da1">More...</a><br /></td></tr>
<tr class="separator:ga3a0345fdcaa033dc2833877975283da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5a5a65c9e2c075881d3ceb30519d3464">spla::MaskPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#ga5a5a65c9e2c075881d3ceb30519d3464">More...</a><br /></td></tr>
<tr class="separator:ga5a5a65c9e2c075881d3ceb30519d3464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gad2eb9ffa56e5ea335f15364ae65fb4b5">spla::MaskByPairKeys</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;mask1, const boost::compute::vector&lt; unsigned int &gt; &amp;mask2, const boost::compute::vector&lt; unsigned int &gt; &amp;keys1, const boost::compute::vector&lt; unsigned int &gt; &amp;keys2, const boost::compute::vector&lt; unsigned int &gt; &amp;values, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys1, boost::compute::vector&lt; unsigned int &gt; &amp;resultKeys2, boost::compute::vector&lt; unsigned int &gt; &amp;resultValues, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mask intersection algorithm.  <a href="group__Internal.html#gad2eb9ffa56e5ea335f15364ae65fb4b5">More...</a><br /></td></tr>
<tr class="separator:gad2eb9ffa56e5ea335f15364ae65fb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </td></tr>
<tr class="memitem:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">spla::MergeByKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItValuesA valuesA, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItValuesB valuesB, ItKeysResult keysResult, ItValuesResult valuesResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by key) sequences of values by given keys.  <a href="group__Internal.html#ga1a0da56195e03b6bc46adffcd70d6faf">More...</a><br /></td></tr>
<tr class="separator:ga1a0da56195e03b6bc46adffcd70d6faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplParams" colspan="2">template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </td></tr>
<tr class="memitem:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">spla::MergeKeys</a> (ItKeysABegin keysABegin, ItKeysAEnd keysAEnd, ItKeysBBegin keysBBegin, ItKeysBEnd keysBEnd, ItKeysResult keysResult, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga606997493cbc46fb9832185c8cdcd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted sequences.  <a href="group__Internal.html#ga606997493cbc46fb9832185c8cdcd9e8">More...</a><br /></td></tr>
<tr class="separator:ga606997493cbc46fb9832185c8cdcd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </td></tr>
<tr class="memitem:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">spla::MergeByPairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput3 valuesA, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItInput6 valuesB, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, ItOutput3 valuesOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga3927ef8d235aad2dd37181a5aae58c9b">More...</a><br /></td></tr>
<tr class="separator:ga3927ef8d235aad2dd37181a5aae58c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplParams" colspan="2">template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </td></tr>
<tr class="memitem:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memTemplItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">spla::MergePairKeys</a> (ItInput1 keysFirstABegin, ItInput1 keysFirstAEnd, ItInput2 keysSecondABegin, ItInput4 keysFirstBBegin, ItInput4 keysFirstBEnd, ItInput5 keysSecondBBegin, ItOutput1 keysFirstOut, ItOutput2 keysSecondOut, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two sorted (by pair key)  <a href="group__Internal.html#ga5c492598b8acdfa5f9a2f5d49cb6aa72">More...</a><br /></td></tr>
<tr class="separator:ga5c492598b8acdfa5f9a2f5d49cb6aa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga06e32a4a916ee651cbbd0c2dabe38f6a">More...</a><br /></td></tr>
<tr class="separator:ga06e32a4a916ee651cbbd0c2dabe38f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16e88e4e8646cce63bdd914347908883"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga16e88e4e8646cce63bdd914347908883">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices1, const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices2, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices1, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices2, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga16e88e4e8646cce63bdd914347908883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga16e88e4e8646cce63bdd914347908883">More...</a><br /></td></tr>
<tr class="separator:ga16e88e4e8646cce63bdd914347908883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, const boost::compute::vector&lt; unsigned char &gt; &amp;inputValues, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::vector&lt; unsigned char &gt; &amp;resultValues, std::size_t elementsInSequence, const std::string &amp;reduceOp, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:gabd2c85fd86f63b4e398320400dc66c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#gabd2c85fd86f63b4e398320400dc66c3a">More...</a><br /></td></tr>
<tr class="separator:gabd2c85fd86f63b4e398320400dc66c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbc66f32ba851d7a14f6213d3814214"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3fbc66f32ba851d7a14f6213d3814214">spla::ReduceDuplicates</a> (const boost::compute::vector&lt; unsigned int &gt; &amp;inputIndices, boost::compute::vector&lt; unsigned int &gt; &amp;resultIndices, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3fbc66f32ba851d7a14f6213d3814214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented.  <a href="group__Internal.html#ga3fbc66f32ba851d7a14f6213d3814214">More...</a><br /></td></tr>
<tr class="separator:ga3fbc66f32ba851d7a14f6213d3814214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">spla::SortByRowColumn</a> (boost::compute::vector&lt; unsigned int &gt; &amp;rows, boost::compute::vector&lt; unsigned int &gt; &amp;cols, boost::compute::vector&lt; unsigned char &gt; &amp;vals, std::size_t elementsInSequence, boost::compute::command_queue &amp;queue)</td></tr>
<tr class="memdesc:ga3b363e3578d72cb1311091ed22d0f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort matrix data in coo format in row-column order.  <a href="group__Internal.html#ga3b363e3578d72cb1311091ed22d0f84b">More...</a><br /></td></tr>
<tr class="separator:ga3b363e3578d72cb1311091ed22d0f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation details. </p>
<p>The internal module implements the full functionality of the library. It is not anticipated that the user will ever need to work with the objects in this module, as it only contains details of the library's implementation. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga93b50c45990a5db2417f40138767a72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93b50c45990a5db2417f40138767a72a">&#9670;&nbsp;</a></span>DeviceError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga93b50c45990a5db2417f40138767a72a">spla::DeviceError</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceError&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga30fcb67db14febcd2559ac50748f59d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30fcb67db14febcd2559ac50748f59d2">&#9670;&nbsp;</a></span>DeviceNotPresent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga30fcb67db14febcd2559ac50748f59d2">spla::DeviceNotPresent</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DeviceNotPresent&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad996df5657793abf71dd4380f1a15e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad996df5657793abf71dd4380f1a15e4d">&#9670;&nbsp;</a></span>DimensionMismatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gad996df5657793abf71dd4380f1a15e4d">spla::DimensionMismatch</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::DimensionMismatch&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga45d873dd1e17d078c56647d26f0e65ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d873dd1e17d078c56647d26f0e65ec">&#9670;&nbsp;</a></span>Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga45d873dd1e17d078c56647d26f0e65ec">spla::Error</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::Error&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga06715d178091c293c2ec3564827fd9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06715d178091c293c2ec3564827fd9c7">&#9670;&nbsp;</a></span>InvalidArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga06715d178091c293c2ec3564827fd9c7">spla::InvalidArgument</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidArgument&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga613ae237941a9d20dfaae339d631c775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613ae237941a9d20dfaae339d631c775">&#9670;&nbsp;</a></span>InvalidState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga613ae237941a9d20dfaae339d631c775">spla::InvalidState</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidState&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafb50a533fa5a48aab0f1dbc73b1f4c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb50a533fa5a48aab0f1dbc73b1f4c35">&#9670;&nbsp;</a></span>InvalidType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafb50a533fa5a48aab0f1dbc73b1f4c35">spla::InvalidType</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::InvalidType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gafd4634b302c77cc636953331de02a81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd4634b302c77cc636953331de02a81c">&#9670;&nbsp;</a></span>MemOpFailed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gafd4634b302c77cc636953331de02a81c">spla::MemOpFailed</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::MemOpFailed&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabcd969f389137654ed73708fd9450197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd969f389137654ed73708fd9450197">&#9670;&nbsp;</a></span>NotImplemented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#gabcd969f389137654ed73708fd9450197">spla::NotImplemented</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NotImplemented&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga424ab0cd09fe4315b95b4e1d2c3a8064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424ab0cd09fe4315b95b4e1d2c3a8064">&#9670;&nbsp;</a></span>NullPointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__Internal.html#ga424ab0cd09fe4315b95b4e1d2c3a8064">spla::NullPointer</a> = typedef <a class="el" href="classspla_1_1TException.html">TException</a>&lt;Status::NullPointer&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5251dcc549917ecb7b44ad073c479962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5251dcc549917ecb7b44ad073c479962">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Internal.html#ga5251dcc549917ecb7b44ad073c479962">spla::Status</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible error status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962abe252e5b290c865b4d033fe4c4f88e9a"></a>DeviceError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a7521f6b5a7670dff6bb1d35275d757b3"></a>DeviceNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a59f6dbcc5566f54790f23d6368767a7e"></a>PlatformNotPresent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a8270b4aa6d8b1673d9512b05cb3b379b"></a>MemOpFailed&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a253ca7dd096ee0956cccee4d376cab8b"></a>InvalidArgument&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962aedf260198e4d75d1cb3c7588f7380120"></a>InvalidState&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962ac85f85f7c13ed006eed130ec183aa810"></a>InvalidType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a260d92b2beff2bf345911077edcd3f3c"></a>NullPointer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a2664c241558d7674e8ed4d5f63d2e463"></a>DimensionMismatch&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga5251dcc549917ecb7b44ad073c479962a997ca4ce119685f40f03a9a8a6c5346e"></a>NotImplemented&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0d5127217f33cc7dec534efb6417496e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d5127217f33cc7dec534efb6417496e">&#9670;&nbsp;</a></span>Gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class MapIterator , class OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::compute::event spla::Gather </td>
          <td>(</td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Custom gather function. Allows to collect input values using permutation. Uses <code>elementsInSequence</code> to collect several elements in row in sequence, i.e. result[i + k] = input[permutation[i] + k] for k in 0..elementsInSequence for i in map range</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of input source values iterator </td></tr>
    <tr><td class="paramname">MapIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of map (permutation iterator) </td></tr>
    <tr><td class="paramname">OutputIterator</td><td><a class="el" href="classspla_1_1Type.html">Type</a> of output (result) gathered values iterator</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Begin of map range </td></tr>
    <tr><td class="paramname">last</td><td>End of map range </td></tr>
    <tr><td class="paramname">input</td><td>Values to map </td></tr>
    <tr><td class="paramname">result</td><td>Where to store result </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>How much values in sequence to copy </td></tr>
    <tr><td class="paramname">queue</td><td>Execution queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a0345fdcaa033dc2833877975283da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a0345fdcaa033dc2833877975283da1">&#9670;&nbsp;</a></span>MaskByKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="gad2eb9ffa56e5ea335f15364ae65fb4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2eb9ffa56e5ea335f15364ae65fb4b5">&#9670;&nbsp;</a></span>MaskByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskByPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Manages associated values with keys. </dd>
<dd>
Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">values</td><td>Associated with keys values </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result values associated with result keys. </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="gada1a694da9f8c13ea97619a4ea99ff65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada1a694da9f8c13ea97619a4ea99ff65">&#9670;&nbsp;</a></span>MaskKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted mask range with the sorted keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Mask elements </td></tr>
    <tr><td class="paramname">keys</td><td>Keys elements </td></tr>
    <tr><td class="paramname">resultKeys</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga5a5a65c9e2c075881d3ceb30519d3464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5a65c9e2c075881d3ceb30519d3464">&#9670;&nbsp;</a></span>MaskPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::MaskPairKeys </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultKeys2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mask intersection algorithm. </p>
<p>Finds the intersection of the sorted pair mask range with the sorted pair keys range and stores it in range starting at resultKeys.</p>
<dl class="section note"><dt>Note</dt><dd>Interprets keys as pairs, where first and second elements stored in separate arrays. </dd>
<dd>
Automatically resizes result containers to result count size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask1</td><td>Mask first elements </td></tr>
    <tr><td class="paramname">mask2</td><td>Mask second elements </td></tr>
    <tr><td class="paramname">keys1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">keys2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">resultKeys1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultKeys2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">queue</td><td>Command queue to perform operations on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of values in intersected region </dd></dl>

</div>
</div>
<a id="ga1a0da56195e03b6bc46adffcd70d6faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0da56195e03b6bc46adffcd70d6faf">&#9670;&nbsp;</a></span>MergeByKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItValuesA , typename ItKeysBBegin , typename ItKeysBEnd , typename ItValuesB , typename ItKeysResult , typename ItValuesResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesA&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesB&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItValuesResult&#160;</td>
          <td class="paramname"><em>valuesResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by key) sequences of values by given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first key sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first key sequence </td></tr>
    <tr><td class="paramname">valuesA</td><td>Begin of the first value sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second key sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second key sequence </td></tr>
    <tr><td class="paramname">valuesB</td><td>Begin of the second value sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the keys result </td></tr>
    <tr><td class="paramname">valuesResult</td><td>Begin of the values result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga3927ef8d235aad2dd37181a5aae58c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3927ef8d235aad2dd37181a5aae58c9b">&#9670;&nbsp;</a></span>MergeByPairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput3 , typename ItInput4 , typename ItInput5 , typename ItInput6 , typename ItOutput1 , typename ItOutput2 , typename ItOutput3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeByPairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput3&#160;</td>
          <td class="paramname"><em>valuesA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput6&#160;</td>
          <td class="paramname"><em>valuesB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput3&#160;</td>
          <td class="paramname"><em>valuesOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga606997493cbc46fb9832185c8cdcd9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga606997493cbc46fb9832185c8cdcd9e8">&#9670;&nbsp;</a></span>MergeKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItKeysABegin , typename ItKeysAEnd , typename ItKeysBBegin , typename ItKeysBEnd , typename ItKeysResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergeKeys </td>
          <td>(</td>
          <td class="paramtype">ItKeysABegin&#160;</td>
          <td class="paramname"><em>keysABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysAEnd&#160;</td>
          <td class="paramname"><em>keysAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBBegin&#160;</td>
          <td class="paramname"><em>keysBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysBEnd&#160;</td>
          <td class="paramname"><em>keysBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItKeysResult&#160;</td>
          <td class="paramname"><em>keysResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keysABegin</td><td>Begin of the first sequence </td></tr>
    <tr><td class="paramname">keysAEnd</td><td>End of the first sequence </td></tr>
    <tr><td class="paramname">keysBBegin</td><td>Begin of the second sequence </td></tr>
    <tr><td class="paramname">keysBEnd</td><td>End of the second sequence </td></tr>
    <tr><td class="paramname">keysResult</td><td>Begin of the result </td></tr>
    <tr><td class="paramname">queue</td><td>OpenCL Command queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence </dd></dl>

</div>
</div>
<a id="ga5c492598b8acdfa5f9a2f5d49cb6aa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c492598b8acdfa5f9a2f5d49cb6aa72">&#9670;&nbsp;</a></span>MergePairKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ItInput1 , typename ItInput2 , typename ItInput4 , typename ItInput5 , typename ItOutput1 , typename ItOutput2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t spla::MergePairKeys </td>
          <td>(</td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput1&#160;</td>
          <td class="paramname"><em>keysFirstAEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput2&#160;</td>
          <td class="paramname"><em>keysSecondABegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput4&#160;</td>
          <td class="paramname"><em>keysFirstBEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItInput5&#160;</td>
          <td class="paramname"><em>keysSecondBBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput1&#160;</td>
          <td class="paramname"><em>keysFirstOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ItOutput2&#160;</td>
          <td class="paramname"><em>keysSecondOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two sorted (by pair key) </p>
<p>@desc In this function, key pair sequence is actually two sequences of keys. Hence, nth key of the first sequence is {<code>keysFirstABegin</code>[n], <code>keysSecondABegin</code>[n]}, and of the second second is {<code>keysFirstBBegin</code>[n], <code>keysSecondBBegin</code>[n]}.</p>
<dl class="section return"><dt>Returns</dt><dd>Size of the merged sequence.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Pair key - a key, which consists of two keys. It is compared lexicographically: first it compares by the first element, and then by the second. </dd></dl>

</div>
</div>
<a id="ga3fbc66f32ba851d7a14f6213d3814214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fbc66f32ba851d7a14f6213d3814214">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices</td><td>Keys elements </td></tr>
    <tr><td class="paramname">resultIndices</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="gabd2c85fd86f63b4e398320400dc66c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2c85fd86f63b4e398320400dc66c3a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Reduces values associated with keys using provided reduceOp. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices</td><td>Keys elements </td></tr>
    <tr><td class="paramname">inputValues</td><td>Input values associated with keys </td></tr>
    <tr><td class="paramname">resultIndices</td><td>Result keys elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result reduced values </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in byte of single value in raw values buffer </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Binary operation used to reduce duplicated values </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="ga16e88e4e8646cce63bdd914347908883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e88e4e8646cce63bdd914347908883">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Keys interpreted as pairs stored in separate containers. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">inputIndices2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">resultIndices1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultIndices2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="ga06e32a4a916ee651cbbd0c2dabe38f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e32a4a916ee651cbbd0c2dabe38f6a">&#9670;&nbsp;</a></span>ReduceDuplicates() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t spla::ReduceDuplicates </td>
          <td>(</td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultIndices2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>reduceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce duplicates in sorted sequence of elements Reduces duplicated values in sorted sequence of key elements, where one or two duplicated keys are presented. </p>
<dl class="section note"><dt>Note</dt><dd>Keys interpreted as pairs stored in separate containers. </dd>
<dd>
Reduces values associated with keys using provided reduceOp. </dd>
<dd>
Result containers automatically resized to store result count values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputIndices1</td><td>Keys first elements </td></tr>
    <tr><td class="paramname">inputIndices2</td><td>Keys second elements </td></tr>
    <tr><td class="paramname">inputValues</td><td>Input values associated with keys </td></tr>
    <tr><td class="paramname">resultIndices1</td><td>Result keys first elements </td></tr>
    <tr><td class="paramname">resultIndices2</td><td>Result keys second elements </td></tr>
    <tr><td class="paramname">resultValues</td><td>Result reduced values </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in byte of single value in raw values buffer </td></tr>
    <tr><td class="paramname">reduceOp</td><td>Binary operation used to reduce duplicated values </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform operation on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count of elements in the result </dd></dl>

</div>
</div>
<a id="ga3b363e3578d72cb1311091ed22d0f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b363e3578d72cb1311091ed22d0f84b">&#9670;&nbsp;</a></span>SortByRowColumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spla::SortByRowColumn </td>
          <td>(</td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::vector&lt; unsigned char &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>elementsInSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::compute::command_queue &amp;&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort matrix data in coo format in row-column order. </p>
<dl class="section note"><dt>Note</dt><dd>If elementsInSequence is 0 and vals is empty, sorts only matrix indices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with row indices to sort </td></tr>
    <tr><td class="paramname">cols</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with column indices to sort </td></tr>
    <tr><td class="paramname">vals</td><td><a class="el" href="classspla_1_1Vector.html">Vector</a> with values byte data </td></tr>
    <tr><td class="paramname">elementsInSequence</td><td>Size in bytes of values in vals vector </td></tr>
    <tr><td class="paramname">queue</td><td>Queue to perform sort operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
